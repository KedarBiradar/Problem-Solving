/*
Pankaj and Rishit has to send encrypted messages to each other. So Pankaj decides on a simple scheme, where A is assigned code 1, B is assigned 2, and so on. (Z is assigned 26).
But Rishit argues that the scheme will be ambiguous, as 111 can be decoded as AAA or AK or KA.
So your task is to tell Pankaj how many different decodings are possible for a given number.

Input Specification:

There will be many testcases. Each number will be of at most 5000 digits.
The first digit of input will never be a zero.
The last line will contain a 0 which would indicate end of input.

Output Specification:

For each number, output in a single line the number of possible decodings.

Constraints:

String length would be at most 5000 digits. Every input would be a valid encryption only.


Sample Input:

 
2614
111
333
0

Sample Output:

 
4
3
1


*/


#include<stdio.h>
#include<string.h>
/*
int get_input( char* str ) {
	int i = 0;
	char ch = 0;
	while ( (ch = getchar() ) != '\n' ) {
		str[i] = ch;
		i++;
	}
	str[i] = '\0';
	return i;
}
*/
int main()
{

char input[5005];
long long int array[5005];
long long int length,i;
//int len;

while(1)
{

scanf("%s",input);

//length=get_input(input);
//get_input(str);

if(input[0]=='0')
	break;

length=strlen(input);

if(length==1)
{
		printf("1\n");
}
else
{

/*for(i=0;i<length+1;i++)
 array[i]=-1;
*/
	array[length]=1;
	
	if(input[length-1]!='0')
	array[length-1]=1;
	else
	array[length-1]=0;


	i=length-2;

	while(i>=0)
	{
		if(input[i]=='0')
			array[i]=0;

		else 
		{
			if(input[i]=='1')
			{

				array[i]=array[i+1]+array[i+2];
			}
			else if(input[i]=='2')
			{
				if(input[i+1]=='0'||input[i+1]=='1'||input[i+1]=='2'||input[i+1]=='3'||input[i+1]=='4'||input[i+1]=='5'||input[i+1]=='6')
					array[i]=array[i+1]+array[i+2];
				else
					array[i]=array[i+1];
			
			}
			else
			{
				array[i]=array[i+1];
			}	
		}
	i--;	
	
	}

	printf("%lld\n",array[0]);

}

}
return 0;
}
